# üè† INMOBILIARIA DB ‚Äî Sistema de Gesti√≥n Inmobiliaria en MySQL

> Base de datos relacional desarrollada en MySQL 8 para administrar el portafolio de propiedades, clientes, contratos y pagos de una inmobiliaria. El sistema est√° normalizado hasta 3FN e incluye funciones personalizadas, triggers de auditor√≠a, seguridad por roles, optimizaci√≥n con √≠ndices, particionamiento, eventos programados, vistas y operaciones CRUD completas.

---

## üìå TABLA DE CONTENIDO

1. [Requisitos](#requisitos)
2. [Estructura de Archivos](#estructura-de-archivos)
3. [Instrucciones de Instalaci√≥n](#instrucciones-de-instalaci√≥n)
4. [Explicaci√≥n del Modelo](#explicaci√≥n-del-modelo)
5. [Componentes del Sistema](#componentes-del-sistema)
6. [Usuarios y Privilegios](#usuarios-y-privilegios)
7. [Ejemplos de Consultas](#ejemplos-de-consultas)
8. [Decisiones de Dise√±o](#decisiones-de-dise√±o)

---

## ‚úÖ REQUISITOS

| Requisito | Versi√≥n m√≠nima |
|---|---|
| MySQL | 8.0 o superior |
| Cliente MySQL | Workbench, DBeaver o l√≠nea de comandos |
| Permisos | Usuario administrador para crear BD y usuarios |

---

## üìÅ ESTRUCTURA DE ARCHIVOS

```
inmobiliaria_db/
‚îÇ
‚îú‚îÄ‚îÄ 1_creacion_base_datos.sql              # DDL + DML: 20 tablas, PKs, FKs y datos de prueba
‚îÇ
‚îú‚îÄ‚îÄ funciones/
‚îÇ   ‚îú‚îÄ‚îÄ calcular_comision.sql              # UDF: comisi√≥n del agente en una venta
‚îÇ   ‚îú‚îÄ‚îÄ calcular_deudapendiente.sql        # UDF: deuda pendiente en contratos de arriendo
‚îÇ   ‚îî‚îÄ‚îÄ obtener_total.sql                  # UDF: total de propiedades disponibles por tipo
‚îÇ
‚îú‚îÄ‚îÄ triggers/
‚îÇ   ‚îú‚îÄ‚îÄ validacion_disponibilidad_contrato.sql    # BEFORE INSERT: valida que la propiedad est√© disponible
‚îÇ   ‚îú‚îÄ‚îÄ Cambio_de_estado_de_una_propiedad.sql     # AFTER UPDATE: audita cambios de estado
‚îÇ   ‚îú‚îÄ‚îÄ Registro_de_un_nuevo_contrato.sql         # AFTER INSERT: audita nuevos contratos
‚îÇ   ‚îî‚îÄ‚îÄ cambio_estado_pagos.sql                   # AFTER UPDATE: audita cambios de estado de pagos
‚îÇ
‚îú‚îÄ‚îÄ seguridad/
‚îÇ   ‚îî‚îÄ‚îÄ seguridad_permisos.sql             # 4 usuarios MySQL con privilegios diferenciados
‚îÇ
‚îú‚îÄ‚îÄ optimizacion/
‚îÇ   ‚îú‚îÄ‚îÄ sp_eliminar_indices.sql            # Elimina los 12 √≠ndices (CONTINUE HANDLER)
‚îÇ   ‚îú‚îÄ‚îÄ sp_crear_indices.sql               # Crea los 12 √≠ndices (EXIT HANDLER)
‚îÇ   ‚îî‚îÄ‚îÄ particiones.sql                    # Particionamiento RANGE por a√±o en tabla Pagos
‚îÇ
‚îú‚îÄ‚îÄ eventos/
‚îÇ   ‚îî‚îÄ‚îÄ evento_programado_mensual.sql      # Evento autom√°tico mensual de pagos pendientes
‚îÇ
‚îú‚îÄ‚îÄ vistas/
‚îÇ   ‚îú‚îÄ‚îÄ vista_contratos_completos.sql      # Une 9 tablas: contrato + cliente + agente + propiedad
‚îÇ   ‚îú‚îÄ‚îÄ vista_pagos_pendientes.sql         # Pagos en estado Pendiente o Vencido
‚îÇ   ‚îî‚îÄ‚îÄ vista_propiedades_disponibles.sql  # Propiedades en estado Disponible
‚îÇ
‚îî‚îÄ‚îÄ crud/
    ‚îú‚îÄ‚îÄ propiedad.sql                      # CREATE, READ, UPDATE, DELETE de propiedades
    ‚îú‚îÄ‚îÄ clientes.sql                       # CREATE, READ, UPDATE, DELETE de clientes
    ‚îú‚îÄ‚îÄ contratos.sql                      # CREATE, READ, UPDATE, DELETE de contratos
    ‚îî‚îÄ‚îÄ pagos.sql                          # CREATE, READ, UPDATE, DELETE de pagos
```

---

## üöÄ INSTRUCCIONES DE INSTALACI√ìN

> ‚ö†Ô∏è **MUY IMPORTANTE:** Ejecuta los scripts **estrictamente en este orden**. Cada script depende del anterior. Si se ejecutan en orden incorrecto, algunos fallar√°n porque las tablas o funciones que necesitan a√∫n no existen.

---

### Paso 1 ‚Äî Crear la base de datos

```sql
SOURCE 1_creacion_base_datos.sql;
```

Crea `inmobiliaria_db` con las 20 tablas, sus PKs, FKs y los datos de prueba iniciales (6 contratos, 9 pagos, 6 propiedades, 9 personas).

---

### Paso 2 ‚Äî Crear las funciones UDF

```sql
SOURCE funciones/calcular_comision.sql;
SOURCE funciones/calcular_deudapendiente.sql;
SOURCE funciones/obtener_total.sql;
```

---

### Paso 3 ‚Äî Crear los triggers

```sql
SOURCE triggers/validacion_disponibilidad_contrato.sql;
SOURCE triggers/Cambio_de_estado_de_una_propiedad.sql;
SOURCE triggers/Registro_de_un_nuevo_contrato.sql;
SOURCE triggers/cambio_estado_pagos.sql;
```

> ‚ö†Ô∏è El trigger `validacion_disponibilidad_contrato` debe crearse primero porque es un BEFORE INSERT. Si se crea despu√©s del AFTER INSERT, el orden de ejecuci√≥n podr√≠a ser incorrecto.

---

### Paso 4 ‚Äî Configurar seguridad y usuarios

```sql
SOURCE seguridad/seguridad_permisos.sql;
```

Crea y configura 4 usuarios MySQL (admin, agente, contador, cliente) con sus respectivos privilegios.

---

### Paso 5 ‚Äî Crear √≠ndices de optimizaci√≥n

```sql
SOURCE optimizacion/sp_eliminar_indices.sql;
SOURCE optimizacion/sp_crear_indices.sql;
```

> El orden es obligatorio: primero eliminar, luego crear. Esto permite re-ejecutar sin errores de √≠ndice duplicado.

---

### Paso 6 ‚Äî Activar el evento programado mensual

```sql
SOURCE eventos/evento_programado_mensual.sql;
```

---

### Paso 7 ‚Äî Crear las vistas

```sql
SOURCE vistas/vista_contratos_completos.sql;
SOURCE vistas/vista_pagos_pendientes.sql;
SOURCE vistas/vista_propiedades_disponibles.sql;
```

---

### Paso 8 ‚Äî Cargar los procedimientos CRUD

```sql
SOURCE crud/propiedad.sql;
SOURCE crud/clientes.sql;
SOURCE crud/contratos.sql;
SOURCE crud/pagos.sql;
```

---

### Paso 9 ‚Äî Particionamiento (optimizaci√≥n avanzada)

```sql
SOURCE optimizacion/particiones.sql;
```

> ‚ö†Ô∏è Este script **elimina y recrea** la tabla `Pagos` con particionamiento RANGE por a√±o. Las FK de Pagos se pierden por limitaci√≥n de MySQL en tablas particionadas. Ejecutar solo si se desea esta optimizaci√≥n avanzada.

---

## üóÇÔ∏è EXPLICACI√ìN DEL MODELO

El modelo parte de una **tabla sin normalizar de 27 columnas** con todo mezclado y llega a **20 tablas en 3FN**, organizadas en 7 grupos funcionales.

---

### Grupo 1 ‚Äî Cat√°logos Base
> Son listas de valores v√°lidos y controlados. Se crean primero porque todas las dem√°s tablas los referencian.

| Tabla | Descripci√≥n |
|---|---|
| `Ciudad` | Ciudades donde opera la inmobiliaria |
| `Barrio` | Barrios por ciudad |
| `TipoPropiedad` | Apartamento, Casa, Local Comercial |
| `EstadoPropiedad` | Disponible, Arrendada, Vendida |
| `EstadoPago` | Pagado, Pendiente, Vencido |
| `Rol` | Administrador, Agente, Cliente, Contador |

---

### Grupo 2 ‚Äî Personas
> Superentidad centralizada. Evita duplicar datos personales en m√∫ltiples tablas.

| Tabla | Descripci√≥n |
|---|---|
| `Personas` | Datos personales de cualquier persona del sistema |
| `Clientes` | Personas que son clientes de la inmobiliaria |
| `Agentes` | Personas que son agentes, con su porcentaje de comisi√≥n |
| `UsuarioSistema` | Cuentas de acceso vinculadas a personas y roles |

---

### Grupo 3 ‚Äî Propiedades

| Tabla | Descripci√≥n |
|---|---|
| `Propiedad` | Inventario de propiedades con tipo, estado y ubicaci√≥n |

---

### Grupo 4 ‚Äî Contratos
> Patr√≥n de especializaci√≥n para eliminar columnas N/A entre arriendos y ventas.

| Tabla | Descripci√≥n |
|---|---|
| `Contratos` | Datos comunes a cualquier contrato (fecha, cliente, agente, propiedad) |
| `ContratoArriendo` | Datos exclusivos de arriendo: valor mensual, fecha inicio y fin |
| `ContratoVenta` | Datos exclusivos de venta: precio, comisi√≥n y fecha de escritura |

---

### Grupo 5 ‚Äî Pagos

| Tabla | Descripci√≥n |
|---|---|
| `Pagos` | Historial de pagos individuales por contrato. Particionada por a√±o. |

---

### Grupo 6 ‚Äî Auditor√≠a y Reportes
> Tablas destino de los triggers y del evento programado.

| Tabla | Descripci√≥n |
|---|---|
| `AuditoriaPropiedad` | Historial autom√°tico de cambios de estado de propiedades |
| `AuditoriaContrato` | Historial autom√°tico de creaci√≥n de contratos |
| `ReportePagos` | Reportes mensuales autom√°ticos de pagos pendientes |

---

### Grupo 7 ‚Äî Logs de Infraestructura
> Sin FK hacia otras tablas. Funcionan de forma aut√≥noma e incondicional.

| Tabla | Descripci√≥n |
|---|---|
| `Logs_Errores` | Registro autom√°tico de errores del sistema |
| `Logs_Cambios` | Registro autom√°tico de operaciones exitosas |

---

## ‚öôÔ∏è COMPONENTES DEL SISTEMA

| Componente | Cantidad | Detalle |
|---|---|---|
| Tablas | 20 | Normalizadas hasta 3FN |
| Funciones UDF | 3 | C√°lculos de negocio: comisi√≥n, deuda, disponibles |
| Triggers | 4 | 2 obligatorios + 2 inferidos |
| Usuarios MySQL | 4 | Con privilegios diferenciados por rol |
| √çndices | 12 | En las tablas m√°s consultadas |
| Evento programado | 1 | Reporte mensual autom√°tico |
| Vistas | 3 | Interfaz simplificada para consultas |
| Procedimientos CRUD | 16 | 4 operaciones √ó 4 entidades principales |
| Particiones | 5 | RANGE por a√±o en tabla Pagos |

---

## üë• USUARIOS Y PRIVILEGIOS

| Usuario MySQL | Rol | Privilegios |
|---|---|---|
| `admin_inmobiliaria` | Administrador | ALL PRIVILEGES + WITH GRANT OPTION |
| `agente_inmobiliario` | Agente | SELECT, INSERT, UPDATE en propiedades, contratos y clientes |
| `contador_inmobiliaria` | Contador | SELECT, INSERT, UPDATE en pagos y reportes |
| `cliente_inmobiliaria` | Cliente | SELECT en propiedades disponibles |

**Contrase√±as:**

| Usuario | Contrase√±a |
|---|---|
| admin_inmobiliaria | `Admin#Inmo2024` |
| agente_inmobiliario | `Agente#Inmo2024` |
| contador_inmobiliaria | `Contador#Inmo2024` |
| cliente_inmobiliaria | `Cliente#Inmo2024` |

---

## üîç EJEMPLOS DE CONSULTAS

### Consultas con vistas

```sql
-- Ver todas las propiedades disponibles
SELECT * FROM vista_propiedades_disponibles;

-- Filtrar por tipo de propiedad
SELECT * FROM vista_propiedades_disponibles
WHERE tipo_propiedad = 'Apartamento';

-- Propiedades disponibles ordenadas por precio
SELECT * FROM vista_propiedades_disponibles
WHERE ciudad = 'Bucaramanga'
ORDER BY precio ASC;

-- Ver todos los contratos con informaci√≥n completa
SELECT * FROM vista_contratos_completos;

-- Ver solo contratos de arriendo
SELECT * FROM vista_contratos_completos
WHERE tipo_contrato = 'Arriendo';

-- Ver pagos pendientes y vencidos
SELECT * FROM vista_pagos_pendientes;

-- Deuda total por cliente
SELECT nombre_cliente, SUM(monto_pendiente) AS deuda_total
FROM vista_pagos_pendientes
GROUP BY nombre_cliente
ORDER BY deuda_total DESC;
```

---

### Consultas con funciones UDF

```sql
-- Calcular comisi√≥n de un agente para una venta espec√≠fica
SELECT calcular_comision('CON-002');

-- Ver comisiones de todas las ventas
SELECT
    c.Contrato_ID,
    CONCAT(p.Nombre, ' ', p.Apellido)  AS agente,
    cv.Precio_Venta,
    calcular_comision(c.Contrato_ID)   AS comision_calculada
FROM contratos c
JOIN agentes a        ON a.Agente_ID    = c.Agente_ID
JOIN personas p       ON p.Persona_ID   = a.Persona_ID
JOIN contratoventa cv ON cv.Contrato_ID = c.Contrato_ID
WHERE c.Tipo_Contrato = 'Venta';

-- Calcular deuda pendiente de un contrato de arriendo
SELECT calcular_deuda_pendiente('CON-001');

-- Deuda pendiente de todos los arriendos
SELECT
    c.Contrato_ID,
    CONCAT(pc.Nombre, ' ', pc.Apellido)     AS cliente,
    calcular_deuda_pendiente(c.Contrato_ID)  AS deuda_pendiente
FROM contratos c
JOIN clientes cl         ON cl.Cliente_ID  = c.Cliente_ID
JOIN personas pc         ON pc.Persona_ID  = cl.Persona_ID
WHERE c.Tipo_Contrato = 'Arriendo';

-- Propiedades disponibles por tipo
SELECT
    tp.Descripcion                            AS tipo_propiedad,
    total_disponibles_por_tipo(tp.TipoP_ID)   AS disponibles
FROM tipopropiedad tp;
```

---

### Consultas con procedimientos CRUD

```sql
-- Registrar una nueva propiedad
CALL sp_insertar_propiedad('PROP-10', 'Cra 15 #30-45', 180000000.00, 'TP-01', 'EP-01', 'BAR-02');

-- Cambiar estado de una propiedad (activa trigger de auditor√≠a autom√°ticamente)
SET @usuario_actual = 'USR-01';
CALL sp_actualizar_estado_propiedad('PROP-10', 'EP-02');

-- Registrar un nuevo cliente
CALL sp_insertar_cliente('PER-20', 'Laura', 'Mart√≠nez', '315-555-0001', 'laura.m@email.com', 'CLI-10');

-- Registrar un nuevo contrato (activa triggers de validaci√≥n y auditor√≠a)
SET @usuario_actual = 'USR-01';
CALL sp_insertar_contrato('CON-010', '2025-03-01', 'Arriendo', 'CLI-01', 'AGE-01', 'PROP-05');

-- Registrar un pago
CALL sp_insertar_pago('PAG-010', 'CON-001', '2025-03-15', 800000.00, 'EPG-02');

-- Marcar un pago como pagado (activa trigger de auditor√≠a de pagos)
SET @usuario_actual = 'USR-04';
CALL sp_actualizar_estado_pago('PAG-010', 'EPG-01');
```

---

### Consultas de auditor√≠a y logs

```sql
-- Historial de cambios de estado de propiedades
SELECT * FROM AuditoriaPropiedad ORDER BY Fecha_Hora DESC;

-- Historial de contratos creados
SELECT * FROM AuditoriaContrato ORDER BY Fecha_Hora DESC;

-- √öltimos errores del sistema
SELECT * FROM Logs_Errores ORDER BY Fecha_Error DESC LIMIT 10;

-- √öltimas operaciones exitosas
SELECT * FROM Logs_Cambios ORDER BY Fecha_Cambio DESC LIMIT 10;

-- Reportes mensuales generados por el evento
SELECT * FROM ReportePagos ORDER BY Periodo DESC;
```

---

### Consultas de verificaci√≥n del sistema

```sql
-- Verificar triggers activos
SHOW TRIGGERS FROM inmobiliaria_db;

-- Verificar funciones creadas
SHOW FUNCTION STATUS WHERE Db = 'inmobiliaria_db';

-- Verificar evento activo
SHOW EVENTS FROM inmobiliaria_db;

-- Verificar √≠ndices
SHOW INDEX FROM contratos;
SHOW INDEX FROM pagos;
SHOW INDEX FROM propiedad;

-- Verificar particiones de Pagos
SELECT PARTITION_NAME, PARTITION_DESCRIPTION, TABLE_ROWS
FROM information_schema.PARTITIONS
WHERE TABLE_SCHEMA = 'inmobiliaria_db'
  AND TABLE_NAME   = 'pagos'
ORDER BY PARTITION_ORDINAL_POSITION;

-- Verificar privilegios de usuarios
SHOW GRANTS FOR 'admin_inmobiliaria'@'localhost';
SHOW GRANTS FOR 'agente_inmobiliario'@'localhost';
SHOW GRANTS FOR 'contador_inmobiliaria'@'localhost';
SHOW GRANTS FOR 'cliente_inmobiliaria'@'localhost';
```

---

## üß† DECISIONES DE DISE√ëO

### Contexto

Una inmobiliaria maneja diariamente informaci√≥n cr√≠tica: propiedades, clientes, agentes, contratos y pagos. Si esa informaci√≥n se almacena de forma desordenada, redundante o inconsistente, el negocio enfrenta riesgos reales: cobros duplicados, estados de propiedad incorrectos, comisiones mal calculadas o contratos sin trazabilidad.

Este modelo parti√≥ de una **tabla sin normalizar con 27 columnas** que mezclaba todo en una sola estructura, y fue llevado paso a paso hasta la **Tercera Forma Normal**, resultando en 20 tablas organizadas, cada una con una responsabilidad clara y sin redundancia de datos.

---

### üî¥ Primera Forma Normal (1FN) ‚Äî Atomicidad de los datos

**Problema:** La tabla original almacenaba m√∫ltiples pagos de un contrato en una sola celda separados por comas:

```
Fechas_Pagos  ‚Üí "2024-01-15, 2024-02-15, 2024-03-15"
Montos_Pagos  ‚Üí "$800.000, $800.000, $800.000"
Estados_Pagos ‚Üí "Pagado, Pagado, Pendiente"
```

**Soluci√≥n:** Cada pago pas√≥ a tener su propia fila con un `Pago_ID` √∫nico. El campo `Nombre_Cliente` se separ√≥ en `Nombre` y `Apellido`.

**Resultado:** El sistema puede consultar, filtrar y reportar cada pago individualmente. El contador puede marcar un pago como pagado sin afectar los dem√°s.

---

### üü° Segunda Forma Normal (2FN) ‚Äî Eliminar dependencias parciales

**Problema:** Con clave primaria compuesta `Contrato_ID + Pago_ID`, columnas como `Nombre_Cliente`, `Tel_Agente` y `Direccion_Propiedad` depend√≠an solo del `Contrato_ID`. Eso es una dependencia parcial. El contrato CON-001 con 3 pagos repet√≠a los datos del cliente en 3 filas id√©nticas.

**Soluci√≥n:** Se crearon tablas independientes: `Personas`, `Clientes`, `Agentes`, `Rol` y `UsuarioSistema`. Los datos personales viven una sola vez en `Personas` y todas las dem√°s tablas los referencian con FK.

**Resultado:** Si un cliente cambia su correo, se modifica en un solo registro y todos sus contratos lo reflejan autom√°ticamente.

---

### üü¢ Tercera Forma Normal (3FN) ‚Äî Eliminar dependencias transitivas

**Problema:** Exist√≠an cadenas de dependencias indirectas:

- `Contrato ‚Üí Propiedad ‚Üí Ciudad ‚Üí Barrio` ‚Äî la ciudad no pertenece al contrato
- `Propiedad ‚Üí TipoPropiedad` ‚Äî "Apartamento" es una categor√≠a, no un dato de la propiedad
- `Pago ‚Üí EstadoPago` ‚Äî "Pagado" es un valor de cat√°logo, no un dato libre

Adem√°s, contratos de Venta ten√≠an `N/A` en columnas de arriendo y viceversa.

**Soluci√≥n:** Se crearon cat√°logos controlados (`Ciudad`, `Barrio`, `TipoPropiedad`, `EstadoPropiedad`, `EstadoPago`, `Rol`) y se implement√≥ especializaci√≥n de contratos: tabla base `Contratos` + tablas especializadas `ContratoArriendo` y `ContratoVenta`.

**Resultado:** Los cat√°logos eliminan errores de digitaci√≥n. La especializaci√≥n elimina columnas vac√≠as y hace el modelo honesto: un arriendo no tiene precio de escritura porque ese concepto no aplica.

---

### üîµ Tablas de Auditor√≠a

`AuditoriaPropiedad` y `AuditoriaContrato` son las tablas destino de los triggers. Cada cambio de estado de una propiedad o cada nuevo contrato se registra autom√°ticamente con el estado anterior, el estado nuevo, la fecha exacta y el usuario responsable. Nadie escribe aqu√≠ manualmente ‚Äî solo los triggers.

`ReportePagos` es la tabla destino del evento mensual. Su campo `Periodo` en formato `YYYY-MM` permite identificar cada ejecuci√≥n y comparar la deuda mes a mes sin sobrescribir datos hist√≥ricos.

---

### ‚ö´ Tablas de Log ‚Äî Decisi√≥n de infraestructura

`Logs_Errores` y `Logs_Cambios` no tienen FK hacia ninguna tabla. Esta decisi√≥n es intencional: si el sistema intenta registrar un error causado por una violaci√≥n de integridad referencial, y el log tambi√©n exige integridad referencial, el log nunca podr√≠a escribirse. Al no tener FK, estas tablas funcionan de forma **aut√≥noma e incondicional**, siempre disponibles sin importar el estado del resto de la base de datos.

---

### Conclusi√≥n

Cada tabla del modelo resolvi√≥ un problema concreto del dise√±o original: redundancia, inconsistencia, datos mezclados, columnas N/A o dependencias incorrectas. El resultado es un modelo de 20 tablas que puede escalar, mantenerse y auditarse con confianza, y que establece las bases exactas para todos los componentes del sistema sin necesidad de modificar la estructura:

- Las funciones UDF operan sobre `ContratoVenta`, `ContratoArriendo` y `Pagos`
- Los triggers escriben en `AuditoriaPropiedad` y `AuditoriaContrato`
- El evento mensual inserta en `ReportePagos`
- La seguridad se implementa sobre `Rol` y `UsuarioSistema`

---

## üìå NOTAS FINALES

- Antes de operar con triggers de auditor√≠a, definir el usuario de sesi√≥n: `SET @usuario_actual = 'USR-XX';`
- El evento mensual requiere: `SET GLOBAL event_scheduler = ON;`
- Para re-ejecutar cualquier script sin errores, cada uno incluye `DROP IF EXISTS` antes de crear
- El particionamiento de Pagos elimina las FK de esa tabla ‚Äî limitaci√≥n documentada de MySQL con tablas particionadas


## AUTORA 
- valentina mancilla 